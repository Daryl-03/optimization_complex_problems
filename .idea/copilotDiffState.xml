<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.c" />
              <option name="originalContent" value="#include &lt;stdio.h&gt;&#10;#include &quot;lib.h&quot;&#10;#include &quot;string.h&quot;&#10;&#10;// Liste des fichiers d'instances&#10;const char* instances[] = {&#10;    &quot;3_3_01.txt&quot;,&#10;    &quot;7_5_01.txt&quot;,&#10;    &quot;20_10_01.txt&quot;,&#10;    &quot;20_20_01.txt&quot;,&#10;    &quot;30_10_01.txt&quot;,&#10;    &quot;30_20_01.txt&quot;,&#10;    &quot;50_10_01.txt&quot;,&#10;    &quot;50_20_01.txt&quot;&#10;};&#10;const int nb_instances = 8;&#10;&#10;Instance *getInstanceByName(const char* instanceName) {&#10;    const char* basePath = &quot;C:\\Users\\Naku\\Desktop\\Naku_desktop\\EILCO\\ING3\\problemes_complexes\\tp1\\instances\\&quot;;&#10;&#10;    char* fullPath = malloc(strlen(basePath) + strlen(instanceName) + 1);&#10;    strcpy(fullPath, basePath);&#10;    strcat(fullPath, instanceName);&#10;&#10;    Instance *instance = read_instance(fullPath);&#10;    free(fullPath);&#10;    return instance;&#10;}&#10;&#10;Instance *getInstance() {&#10;    return getInstanceByName(&quot;20_10_01.txt&quot;);&#10;}&#10;&#10;// Fonction de test pour la Question 9&#10;// Teste les 4 algorithmes (marche aléatoire, climber_first, climber_best, algo_perso) &#10;// avec les 2 voisinages (INSERTION, ECHANGE) = 8 versions&#10;// k = nombre d'exécutions par méthode&#10;// n = nombre de solutions évaluées pour marche_aleatoire&#10;void test_algorithmes(Instance *instance, int k, double n) {&#10;    printf(&quot;\n=== Test des algorithmes ===\n&quot;);&#10;    printf(&quot;Instance: %d jobs, %d machines\n&quot;, instance-&gt;nombreDeJobs, instance-&gt;nombreDeMachines);&#10;    printf(&quot;Nombre d'executions (k): %d\n&quot;, k);&#10;    printf(&quot;Nombre d'iterations pour marche aleatoire (n): %.0f\n\n&quot;, n);&#10;&#10;    // Tableau pour stocker les résultats&#10;    // 4 algorithmes × 2 opérations = 8 variantes&#10;    const char* algo_names[] = {&quot;Marche Aleatoire&quot;, &quot;Climber First&quot;, &quot;Climber Best&quot;, &quot;Algo Perso&quot;};&#10;    const char* op_names[] = {&quot;INSERTION&quot;, &quot;ECHANGE&quot;};&#10;    &#10;    for (int algo = 0; algo &lt; 4; algo++) {&#10;        for (int op = 0; op &lt; 2; op++) {&#10;            Operation operation = (op == 0) ? INSERTION : ECHANGE;&#10;            double total_cmax = 0.0;&#10;            double total_evaluations = 0.0;&#10;            &#10;            for (int exec = 0; exec &lt; k; exec++) {&#10;                Solution sol = {0};&#10;                int nb_evaluations = 0;&#10;                &#10;                switch (algo) {&#10;                    case 0: // Marche aléatoire&#10;                        sol = marche_aleatoire_op(instance, n, operation);&#10;                        nb_evaluations = (int)n;&#10;                        break;&#10;                    case 1: // Climber first&#10;                        sol = climber_first(instance, operation);&#10;                        // Estimation du nombre d'évaluations pour climber&#10;                        // (Dans une vraie implémentation, il faudrait tracker ce nombre)&#10;                        nb_evaluations = instance-&gt;nombreDeJobs * (instance-&gt;nombreDeJobs - 1);&#10;                        break;&#10;                    case 2: // Climber best&#10;                        sol = climber_best(instance, operation);&#10;                        nb_evaluations = instance-&gt;nombreDeJobs * (instance-&gt;nombreDeJobs - 1);&#10;                        break;&#10;                    case 3: // Algo perso&#10;                        sol = algo_perso(instance, operation, n);&#10;                        nb_evaluations = (int)n;&#10;                        break;&#10;                    default:&#10;                        break;&#10;                }&#10;                &#10;                total_cmax += sol.cmax;&#10;                total_evaluations += nb_evaluations;&#10;                &#10;                // Libérer la mémoire de la solution&#10;                free(sol.jobOrder);&#10;            }&#10;            &#10;            double moyenne_cmax = total_cmax / k;&#10;            double moyenne_evaluations = total_evaluations / k;&#10;            &#10;            printf(&quot;%-20s | %-10s | Cout moyen: %10.2f | Evaluations moyennes: %10.0f\n&quot;,&#10;                   algo_names[algo], op_names[op], moyenne_cmax, moyenne_evaluations);&#10;        }&#10;    }&#10;    printf(&quot;\n&quot;);&#10;}&#10;&#10;// Fonction principale de test pour toutes les instances&#10;void test_toutes_instances(int k, double n) {&#10;    printf(&quot;╔════════════════════════════════════════════════════════════════════════════════╗\n&quot;);&#10;    printf(&quot;║              TEST DES ALGORITHMES SUR TOUTES LES INSTANCES                     ║\n&quot;);&#10;    printf(&quot;╚════════════════════════════════════════════════════════════════════════════════╝\n\n&quot;);&#10;    &#10;    for (int i = 0; i &lt; nb_instances; i++) {&#10;        printf(&quot;================================================================================\n&quot;);&#10;        printf(&quot;                      INSTANCE: %s\n&quot;, instances[i]);&#10;        printf(&quot;================================================================================\n&quot;);&#10;        &#10;        Instance *instance = getInstanceByName(instances[i]);&#10;        if (instance == NULL) {&#10;            printf(&quot;Erreur: impossible de charger l'instance %s\n\n&quot;, instances[i]);&#10;            continue;&#10;        }&#10;        &#10;        test_algorithmes(instance, k, n);&#10;        &#10;        free_instance(instance);&#10;    }&#10;    &#10;    printf(&quot;================================================================================\n&quot;);&#10;    printf(&quot;                           FIN DES TESTS\n&quot;);&#10;    printf(&quot;================================================================================\n&quot;);&#10;}&#10;&#10;int launch_Optimization(){&#10;    Instance *instance = getInstance();&#10;&#10;    if(instance == NULL){&#10;        printf(&quot;no instance&quot;);&#10;        return 0;&#10;    }&#10;&#10;    afficher_instance(*instance);&#10;&#10;&#10;    clock_t start, stop;&#10;    start = clock();&#10;&#10;    double nombre_iterations = 100000;&#10;    printf(&quot;Marche aleatoire de %.f iterations :\n&quot;, nombre_iterations);&#10;    Solution solution_marche_insertion = marche_aleatoire_op(instance, nombre_iterations, INSERTION);&#10;    Solution solution_marche_echange = marche_aleatoire_op(instance, nombre_iterations, ECHANGE);&#10;&#10;    printf(&quot;\n&quot;);&#10;    printf(&quot;%f insertion vs %f echange\n&quot;, solution_marche_insertion.cmax, solution_marche_echange.cmax);&#10;&#10;    printf(&quot;Climber first \n&quot;);&#10;    Solution solution_climb_first_ins = climber_first(instance, INSERTION);&#10;    afficher_solution(solution_climb_first_ins);&#10;    Solution solution_climb_first_ech = climber_first(instance, ECHANGE);&#10;    afficher_solution(solution_climb_first_ech);&#10;    printf(&quot;Apres climb first insertion :\n&quot;);&#10;&#10;&#10;    Solution solution_climb_best = climber_best(instance, INSERTION);&#10;    printf(&quot;Apres climb best :\n&quot;);&#10;    afficher_solution(solution_climb_best);&#10;&#10;    stop = clock();&#10;&#10;    double time = (double)(stop - start) / CLOCKS_PER_SEC;&#10;    printf(&quot;Le calcul a pris %.2f millisecondes\n&quot;, time*1000);&#10;&#10;//    free(solution);&#10;    free_instance(instance);&#10;    return 1;&#10;}&#10;&#10;int main(void) {&#10;&#10;    srand(time(NULL));&#10;&#10;    // Question 9: Test des algorithmes&#10;    // k = nombre d'exécutions par méthode&#10;    // n = nombre d'itérations pour la marche aléatoire&#10;    int k = 10;        // 10 exécutions par méthode&#10;    double n = 10000;  // 10000 itérations pour marche aléatoire&#10;    &#10;    test_toutes_instances(k, n);&#10;&#10;    return 0;&#10;}" />
              <option name="updatedContent" value="#include &lt;stdio.h&gt;&#10;#include &quot;lib.h&quot;&#10;#include &quot;string.h&quot;&#10;&#10;// Liste des fichiers d'instances&#10;const char* instances[] = {&#10;    &quot;3_3_01.txt&quot;,&#10;    &quot;7_5_01.txt&quot;,&#10;    &quot;20_10_01.txt&quot;,&#10;    &quot;20_20_01.txt&quot;,&#10;    &quot;30_10_01.txt&quot;,&#10;    &quot;30_20_01.txt&quot;,&#10;    &quot;50_10_01.txt&quot;,&#10;    &quot;50_20_01.txt&quot;&#10;};&#10;const int nb_instances = 8;&#10;&#10;Instance *getInstanceByName(const char* instanceName) {&#10;    const char* basePath = &quot;C:\\Users\\Naku\\Desktop\\Naku_desktop\\EILCO\\ING3\\problemes_complexes\\tp1\\instances\\&quot;;&#10;&#10;    char* fullPath = malloc(strlen(basePath) + strlen(instanceName) + 1);&#10;    strcpy(fullPath, basePath);&#10;    strcat(fullPath, instanceName);&#10;&#10;    Instance *instance = read_instance(fullPath);&#10;    free(fullPath);&#10;    return instance;&#10;}&#10;&#10;Instance *getInstance() {&#10;    return getInstanceByName(&quot;20_10_01.txt&quot;);&#10;}&#10;&#10;// Fonction de test pour la Question 9&#10;// Teste les 4 algorithmes (marche aléatoire, climber_first, climber_best, algo_perso) &#10;// avec les 2 voisinages (INSERTION, ECHANGE) = 8 versions&#10;// k = nombre d'exécutions par méthode&#10;// n = nombre de solutions évaluées pour marche_aleatoire&#10;void test_algorithmes(Instance *instance, int k, double n) {&#10;    printf(&quot;\n=== Test des algorithmes ===\n&quot;);&#10;    printf(&quot;Instance: %d jobs, %d machines\n&quot;, instance-&gt;nombreDeJobs, instance-&gt;nombreDeMachines);&#10;    printf(&quot;Nombre d'executions (k): %d\n&quot;, k);&#10;    printf(&quot;Nombre d'iterations pour marche aleatoire (n): %.0f\n\n&quot;, n);&#10;&#10;    // Tableau pour stocker les résultats&#10;    // 4 algorithmes × 2 opérations = 8 variantes&#10;    const char* algo_names[] = {&quot;Marche Aleatoire&quot;, &quot;Climber First&quot;, &quot;Climber Best&quot;, &quot;Algo Perso&quot;};&#10;    const char* op_names[] = {&quot;INSERTION&quot;, &quot;ECHANGE&quot;};&#10;    &#10;    for (int algo = 0; algo &lt; 4; algo++) {&#10;        for (int op = 0; op &lt; 2; op++) {&#10;            Operation operation = (op == 0) ? INSERTION : ECHANGE;&#10;            double total_cmax = 0.0;&#10;            double total_evaluations = 0.0;&#10;            &#10;            for (int exec = 0; exec &lt; k; exec++) {&#10;                Solution sol = {0};&#10;                int nb_evaluations = 0;&#10;                &#10;                switch (algo) {&#10;                    case 0: // Marche aléatoire&#10;                        sol = marche_aleatoire_op(instance, n, operation);&#10;                        nb_evaluations = (int)n;&#10;                        break;&#10;                    case 1: // Climber first&#10;                        sol = climber_first(instance, operation);&#10;                        // Estimation du nombre d'évaluations pour climber&#10;                        // (Dans une vraie implémentation, il faudrait tracker ce nombre)&#10;                        nb_evaluations = instance-&gt;nombreDeJobs * (instance-&gt;nombreDeJobs - 1);&#10;                        break;&#10;                    case 2: // Climber best&#10;                        sol = climber_best(instance, operation);&#10;                        nb_evaluations = instance-&gt;nombreDeJobs * (instance-&gt;nombreDeJobs - 1);&#10;                        break;&#10;                    case 3: // Algo perso&#10;                        sol = algo_perso(instance, operation, n);&#10;                        nb_evaluations = (int)n;&#10;                        break;&#10;                    default:&#10;                        break;&#10;                }&#10;                &#10;                total_cmax += sol.cmax;&#10;                total_evaluations += nb_evaluations;&#10;                &#10;                // Libérer la mémoire de la solution&#10;                free(sol.jobOrder);&#10;            }&#10;            &#10;            double moyenne_cmax = total_cmax / k;&#10;            double moyenne_evaluations = total_evaluations / k;&#10;            &#10;            printf(&quot;%-20s | %-10s | Cout moyen: %10.2f | Evaluations moyennes: %10.0f\n&quot;,&#10;                   algo_names[algo], op_names[op], moyenne_cmax, moyenne_evaluations);&#10;        }&#10;    }&#10;    printf(&quot;\n&quot;);&#10;}&#10;&#10;// Fonction principale de test pour toutes les instances&#10;void test_toutes_instances(int k, double n) {&#10;    printf(&quot;╔════════════════════════════════════════════════════════════════════════════════╗\n&quot;);&#10;    printf(&quot;║              TEST DES ALGORITHMES SUR TOUTES LES INSTANCES                     ║\n&quot;);&#10;    printf(&quot;╚════════════════════════════════════════════════════════════════════════════════╝\n\n&quot;);&#10;    &#10;    for (int i = 0; i &lt; nb_instances; i++) {&#10;        printf(&quot;================================================================================\n&quot;);&#10;        printf(&quot;                      INSTANCE: %s\n&quot;, instances[i]);&#10;        printf(&quot;================================================================================\n&quot;);&#10;        &#10;        Instance *instance = getInstanceByName(instances[i]);&#10;        if (instance == NULL) {&#10;            printf(&quot;Erreur: impossible de charger l'instance %s\n\n&quot;, instances[i]);&#10;            continue;&#10;        }&#10;        &#10;        test_algorithmes(instance, k, n);&#10;        &#10;        free_instance(instance);&#10;    }&#10;    &#10;    printf(&quot;================================================================================\n&quot;);&#10;    printf(&quot;                           FIN DES TESTS\n&quot;);&#10;    printf(&quot;================================================================================\n&quot;);&#10;}&#10;&#10;int launch_Optimization(){&#10;    Instance *instance = getInstance();&#10;&#10;    if(instance == NULL){&#10;        printf(&quot;no instance&quot;);&#10;        return 0;&#10;    }&#10;&#10;    afficher_instance(*instance);&#10;&#10;&#10;    clock_t start, stop;&#10;    start = clock();&#10;&#10;    double nombre_iterations = 100000;&#10;    printf(&quot;Marche aleatoire de %.f iterations :\n&quot;, nombre_iterations);&#10;    Solution solution_marche_insertion = marche_aleatoire_op(instance, nombre_iterations, INSERTION);&#10;    Solution solution_marche_echange = marche_aleatoire_op(instance, nombre_iterations, ECHANGE);&#10;&#10;    printf(&quot;\n&quot;);&#10;    printf(&quot;%f insertion vs %f echange\n&quot;, solution_marche_insertion.cmax, solution_marche_echange.cmax);&#10;&#10;    printf(&quot;Climber first \n&quot;);&#10;    Solution solution_climb_first_ins = climber_first(instance, INSERTION);&#10;    afficher_solution(solution_climb_first_ins);&#10;    Solution solution_climb_first_ech = climber_first(instance, ECHANGE);&#10;    afficher_solution(solution_climb_first_ech);&#10;    printf(&quot;Apres climb first insertion :\n&quot;);&#10;&#10;&#10;    Solution solution_climb_best = climber_best(instance, INSERTION);&#10;    printf(&quot;Apres climb best :\n&quot;);&#10;    afficher_solution(solution_climb_best);&#10;&#10;    stop = clock();&#10;&#10;    double time = (double)(stop - start) / CLOCKS_PER_SEC;&#10;    printf(&quot;Le calcul a pris %.2f millisecondes\n&quot;, time*1000);&#10;&#10;//    free(solution);&#10;    free_instance(instance);&#10;    return 1;&#10;}&#10;&#10;int main(void) {&#10;&#10;    srand(time(NULL));&#10;&#10;    // Question 9: Test des algorithmes&#10;    // k = nombre d'exécutions par méthode&#10;    // n = nombre d'itérations pour la marche aléatoire&#10;    int k = 10;        // 10 exécutions par méthode&#10;    double n = 10000;  // 10000 itérations pour marche aléatoire&#10;    &#10;    test_toutes_instances(k, n);&#10;&#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>